{
    "componentChunkName": "component---src-templates-post-template-tsx",
    "path": "/2022-03-13/JS_variable/",
    "result": {"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<p><b>var</b>는 자바스크립트의 역사와 함께했던 유구한 문법, 전통적으로 변수를 만들때 사용한 키워드다.<br>\n그런데 크롬 브라우저 기준 2016년 문법부터 let, const라는 새로운 문법이 탑재되었다.</p>\n<h3>let과 const는 어떨 때 사용할까?</h3>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> price <span class=\"token operator\">=</span> <span class=\"token number\">10000</span>\r\n<span class=\"token keyword\">const</span> vat_percent <span class=\"token operator\">=</span> <span class=\"token number\">0.1</span>\r\n<span class=\"token keyword\">let</span> vat <span class=\"token operator\">=</span> price <span class=\"token operator\">*</span> vat_percent\r\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>vat<span class=\"token punctuation\">)</span></code></pre></div>\n<p>위의 코드를 보면 가격(price)는 let을 쓰고 있으며 값은 10000이다.<br>\n가격은 언제든지 물가에 따라 변동 될 수 있다.<br>\n부가가치세율(vat_percent)은 법으로 지정되어 있으며 한국에서는 10%의 부가가치세율이 붙는다.<br>\n이 값이 바뀌진 않기에 const를 붙이며, const는 상수라고 하고 변하지 않는 값에 주로 붙는다.<br>\n이름의 값이 바뀔 수 있다면 let을 쓰고 바뀌지 않는 고정된 값이라면 const를 쓴다는 것을 알아두자\r\n<br/><br/>\r\nlet, const과 var의 차이점에 대해서 더 알아보자</p>\n<p>우선 var는 global scope에 선언되며 let과 const는 script scope에 선언된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> foo <span class=\"token operator\">=</span> <span class=\"token string\">'foo'</span> <span class=\"token comment\">// global scope</span>\r\n<span class=\"token keyword\">let</span> bar <span class=\"token operator\">=</span> <span class=\"token string\">'bar'</span> <span class=\"token comment\">// script scope</span>\r\n<span class=\"token keyword\">const</span> woo <span class=\"token operator\">=</span> <span class=\"token string\">'woo'</span> <span class=\"token comment\">// script scope</span></code></pre></div>\n<p>let과 const는 전역객체에 속성을 부여하지 않는다는 의미이다.<br>\n따라서 최상위 객체인 window에 속성을 생성하지 않기 때문에 window를 통해 값을 불러올 수 없다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> foo <span class=\"token operator\">=</span> <span class=\"token string\">'foo'</span>\r\n<span class=\"token keyword\">let</span> bar <span class=\"token operator\">=</span> <span class=\"token string\">'bar'</span>\r\n\r\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">.</span>foo<span class=\"token punctuation\">)</span>\r\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">.</span>bar<span class=\"token punctuation\">)</span></code></pre></div>\n<p>따라서 let이나 const로 선언된 변수나 상수는 window를 통해 var와 let, const 모두 함수 내에 선언한 경우<br>\nfunction local scope에 선언된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">example</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n  <span class=\"token keyword\">var</span> foo <span class=\"token operator\">=</span> <span class=\"token string\">'foo'</span> <span class=\"token comment\">// local scope</span>\r\n  <span class=\"token keyword\">let</span> bar <span class=\"token operator\">=</span> <span class=\"token string\">'bar'</span> <span class=\"token comment\">// local scope</span>\r\n  <span class=\"token keyword\">const</span> woo <span class=\"token operator\">=</span> <span class=\"token string\">'woo'</span> <span class=\"token comment\">// local scope</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>그리고 자바스크립트에는 block이라는 scope가 있는데 var는 global, let 과 const는 block scope에 선언된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token punctuation\">{</span>\r\n  <span class=\"token keyword\">var</span> foo <span class=\"token operator\">=</span> <span class=\"token string\">'foo'</span> <span class=\"token comment\">// global scope</span>\r\n  <span class=\"token keyword\">let</span> bar <span class=\"token operator\">=</span> <span class=\"token string\">'bar'</span> <span class=\"token comment\">// block scope</span>\r\n  <span class=\"token keyword\">const</span> woo <span class=\"token operator\">=</span> <span class=\"token string\">'woo'</span> <span class=\"token comment\">// block scope</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>let과 const가 나온 뒤로 var보다는 let을 사용하는 것을 권장하며 만약 값이 변하지 않는 고정 된 값이라면 const를 사용하도록 하고 있다.</p>\n<h3>왜 var보다 let을 사용하도록 권장하는 것 일까?</h3>\n<ol>\n<li>범위 규칙이 엄격하다.</li>\n<li>호이스팅이 없다.</li>\n<li>재정의를 막아준다.</li>\n</ol>\n<p><strong>1. 범위 규칙이 엄격하다.</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">example</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n  <span class=\"token keyword\">var</span> foo <span class=\"token operator\">=</span> <span class=\"token string\">'foo'</span>\r\n  <span class=\"token keyword\">let</span> bar <span class=\"token operator\">=</span> <span class=\"token string\">'bar'</span>\r\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">,</span> bar<span class=\"token punctuation\">)</span> <span class=\"token comment\">// foo bar</span>\r\n  <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">let</span> woo <span class=\"token operator\">=</span> <span class=\"token string\">'woo'</span>\r\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>woo<span class=\"token punctuation\">)</span> <span class=\"token comment\">// woo</span>\r\n  <span class=\"token punctuation\">}</span>\r\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>woo<span class=\"token punctuation\">)</span> <span class=\"token comment\">// Uncaught ReferenceError: woo is not defined</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token function\">example</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>위 코드는 let으로 선언된 woo를 중괄호 밖에서 실행할 때 레퍼런스 오류(해당 변수가 정의되지 않음)를 발생시킨다.<br>\nlet을 var로 바꿔서 돌려보면 문제 없이 실행되는 것을 확인 할 수 있다.<br>\nlet은 자신을 둘러싼 제일 scope안에서만 작동하는 것에 비해 var는 함수안에서 선언된다면 function scope까지 함수 바깥에 선언된다면 global scope까지 작동한다.\r\n<br/><br/>\r\n<strong>2. 호이스팅(Hosting, 끌어올리기)이 없다.</strong></p>\n<p>호이스팅에 대한 설명은 본 설명이 끝난 다음 추가하겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">example_one</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">)</span> <span class=\"token comment\">// undefined</span>\r\n  <span class=\"token keyword\">var</span> foo <span class=\"token operator\">=</span> <span class=\"token string\">'foo'</span>\r\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">)</span> <span class=\"token comment\">// foo</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token keyword\">function</span> <span class=\"token function\">example_two</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>bar<span class=\"token punctuation\">)</span> <span class=\"token comment\">// Uncaught ReferenceError</span>\r\n  <span class=\"token keyword\">let</span> bar <span class=\"token operator\">=</span> <span class=\"token string\">'bar'</span>\r\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>bar<span class=\"token punctuation\">)</span> <span class=\"token comment\">// bar</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>example_one의 코드에서 위쪽 console.log는 자신 아래에 정의된 변수를 끌어올려 불러온다.<br>\n(변수가 정의되었다는 것만 알고 초기화된 값까지 불러오진 않지만, 중요한 것은 에러가 없다는 것이다.)<br>\n반면 example_two의 코드에서 bar라는 변수가 정의되지 않았다는 에러를 발생시킨다.\r\n<br/><br/>\r\n<strong>3.재정의를 막아준다.</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> foo <span class=\"token operator\">=</span> <span class=\"token string\">'foo1'</span>\r\n<span class=\"token keyword\">var</span> foo <span class=\"token operator\">=</span> <span class=\"token string\">'foo2'</span>\r\n\r\n<span class=\"token keyword\">let</span> bar <span class=\"token operator\">=</span> <span class=\"token string\">'bar1'</span>\r\n<span class=\"token keyword\">let</span> bar <span class=\"token operator\">=</span> <span class=\"token string\">'bar2'</span> <span class=\"token comment\">// Uncaught SyntaxError</span></code></pre></div>\n<p>재정의를 할 경우 var는 허용되지만 let은 허용되지 않고 SyntaxError를 발생시킨다.<br>\n위의 경우도 중요한 건데 변수를 선언한다는 것은 해당 변수가 존재하지 않기에 새로 변수를 선언해준다는 의미인데<br>\n만약 var와 같이 이미 선언된 변수를 재선언하게 된다면 이는 오류로 이어질 수 있다.</p>\n<p>var, let 그리고 const는 scope별로 어떻게 동작하는지 전체적으로 알고 싶다면 아래 표를 확인해보자\r\n<br/><br/></p>\n<p align=\"center\"><img src='/images/JavaScript/variable.png' width='80%' alt='lcs one' /><p>\n<h3>그렇다면 호이스팅이 무엇일까?</h3>\n<p>호이스팅은 코드가 실행되기 전에 변수선언/함수선언이 해당 스코프의 최상단으로 끌어 올려진 것 같은 현상을 말한다.\r\nJS 엔진은 스크립트를 가져 오면 <strong>가장 먼저 코드에서 데이터를 위한 메모리를 설정한다.</strong><br>\n이 시점에는 코드가 실행되지는 않고 실행을 하기 위한 준비단계이다.</p>\n<p>함수와 변수가 메모리에 저장되는 방식은 다르다.</p>\n<ul>\n<li><strong>함수는 전체 함수에 대한 참조와 함께 저장된다.</strong></li>\n<li><strong>변수의 경우 ES6 문법인 let과 const는 초기화 되지 않은 채로 저장이 되고, var는 undefined로 저장이 된다.</strong></li>\n</ul>\n<h3>변수는 어떻게 생성되고, 호이스팅은 어떻게 이뤄지게 될까?</h3>\n<p><strong>1단계: 선언 단계(Declaration phase)</strong><br>\n변수를 실행 컨텍스트의 변수 객체에 등록하며 이 변수 객체는 스코프가 참조하는 대상이 된다.</p>\n<p><strong>2단계: 초기화 단계(Initialization phase)</strong><br>\n변수 객체에 등록된 변수를 위한 공간을 메모리에 확보하며 이 단계에서 변수는 undefined로 초기화가 된다.</p>\n<p><strong>3단계: 할당 단계(Assignment phase)</strong><br>\nundefined로 초기화된 변수에 실제 값을 할당하게 된다.</p>\n<p>var는 호이스팅이 발생하게 되면 선언과 초기화가 거의 동시에 이루어진다.<br>\n실행 시점의 스코프의 최상단에서 해당 변수에 대한 메모리가 살아있기 때문에 선언부 위치에 상관하지 않고 참조 및 할당이 가능하다.\r\nlet, const는 호이스팅이 발생하면, 선언만 이루어지며 실행 시점에서 실질적인 선언부를 만나기 전까진 초기화는 이루어지지 않는다.<br>\n이 간극만큼 해당 변수에 대한 메모리는 존재하지 않기에 선언부 상단에서 참조 및 할당이 불가능하게 되며, 이 간극을 일시적 사각지대, <b>TDZ(Temporal Dead Zone)</b>라고 한다.\r\n변수는 존재하지만, 초기화가 되어있지 않는 것이다.\r\n<br/><br/>\r\n호이스팅에는 변수선언일 때 호이스팅과 함수 선언에서의 호이스팅이 있다.</p>\n<p>함수 호이스팅은 다른 무엇보다 가장 먼저 이루어진다.\r\n그리고 함수 호이스팅은 오직 선언문에서만 가능하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">foo1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 함수 선언문에서는 호이스팅</span>\r\n<span class=\"token function\">foo2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 함수 표현식이라서 호이스팅 X</span>\r\n\r\n<span class=\"token keyword\">function</span> <span class=\"token function\">foo1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Hello'</span><span class=\"token punctuation\">)</span>\r\n<span class=\"token punctuation\">}</span>\r\n<span class=\"token keyword\">var</span> <span class=\"token function-variable function\">foo2</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'world'</span><span class=\"token punctuation\">)</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>변수 선언에서의 호이스팅은 위에 설명했다시피 var에서는 가능하지만 let과 const에서는 불가능하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// var 호이스팅</span>\r\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">)</span> <span class=\"token comment\">// foo! (선언 + 초기화 된 상태)</span>\r\nfoo <span class=\"token operator\">=</span> <span class=\"token string\">'foo!'</span> <span class=\"token comment\">// (선언 + 초기화 + 할당 된 상태)</span>\r\n<span class=\"token keyword\">var</span> foo\r\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">)</span> <span class=\"token comment\">// foo!</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Uncaught SyntaxError (선언 된 상태, 초기화(메모리 공간 확보와 undefined로 초기화) 안되서 참조 불가능 -> 에러)</span>\r\n<span class=\"token keyword\">let</span> foo<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 여기서 초기화 단계가 실행</span>\r\n<span class=\"token keyword\">const</span> bar<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Uncaught SyntaxError (const 키워드는 재할당 및 재선언 불가능, 선언과 동시에 할당해야 함)</span></code></pre></div>\n<p>호이스팅은 자바스크립트의 특성에 따라 코드 실행 전 컴파일을 거치며 자연스럽게 귀결되는 전처리 과정이지만<br>\nundefined나 reference error와 같이 호이스팅의 사이드 이펙트(Side Effect)를 피하기 위해서는 항상 변수를 현재 스코프 최상단에서 선언하도록 하고, 선언과 함께 초기화를 진행해야한다.</p>","frontmatter":{"title":"var, let, const 그리고 Hoisting","summary":"var, let const에 대한 차이와 호이스팅에 대해서 알아보자","date":"2022.03.13.","categories":["JavaScript"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAAA7DAAAOwwHHb6hkAAABgElEQVQ4y+2UzyvDYRzH/QOWE6VY+ZGI0jdDSK2lOLDLDqjV2C+z+TUnlxHhoOSwkprbSi5OKw4OO7hSko0trclwUOIg8eWl72Pf2kG21W4cPn36PM/neT/v9/v59BRx6aAw4YSohaI/DPh5YRf5I2pHjtpF/R6x8X5uE1ndV3NODD+U5oQLkq7vtZQH7ifg1gOx38B+AFSYcT1OaKuX4JoekuMsz+jolMqY90iCaU4M1YbXMyvcefCONDE2VM9BoI+qimLOQiaMBi37gT64cSNH7HxmYyjYKTIfp5lzNjNpbuTqcJAarQarqY7t5W6eTywQd2ZnKKel7vl7SIaH8fs6MRtrhWdHOwPsrBtoqC5hcapFeJn5QD8CvinePEwJqe3NpejbylmdbSUc7Ke6UiM87ZDKWFIA73IAFJsxBy+no6x4dfjcEk/HFkiMsbthEJI3F7ryGxvRFHcKBiJUr1Lu/Mcm82YxyGlJSsjpOq/BVg+rzZkH1Do72P9vU0jAL+WuodgKRyMEAAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/ff8baacb3b7e020448d56932a93a427d/9b9a6/javascript_thumbnail.png","srcSet":"/static/ff8baacb3b7e020448d56932a93a427d/b78f2/javascript_thumbnail.png 112w,\n/static/ff8baacb3b7e020448d56932a93a427d/022a4/javascript_thumbnail.png 223w,\n/static/ff8baacb3b7e020448d56932a93a427d/9b9a6/javascript_thumbnail.png 446w","sizes":"(min-width: 446px) 446px, 100vw"},"sources":[{"srcSet":"/static/ff8baacb3b7e020448d56932a93a427d/5b8e6/javascript_thumbnail.webp 112w,\n/static/ff8baacb3b7e020448d56932a93a427d/cd3d4/javascript_thumbnail.webp 223w,\n/static/ff8baacb3b7e020448d56932a93a427d/48be0/javascript_thumbnail.webp 446w","type":"image/webp","sizes":"(min-width: 446px) 446px, 100vw"}]},"width":446,"height":414.99999999999994}},"publicURL":"/static/ff8baacb3b7e020448d56932a93a427d/javascript_thumbnail.png"}}}}]}},"pageContext":{"slug":"/2022-03-13/JS_variable/"}},
    "staticQueryHashes": []}