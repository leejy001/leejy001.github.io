---
date: '2022-03-25'
title: '동적 계획법(Dynamic programming)'
categories: ['JavaScript', 'Algorithm']
summary: '동적 계획법의 개념과 동적 계획법으로 문제를 푸는 방법에 대해서 알아보자'
thumbnail: './algorithm.png'
---

### 알고리즘 정리 6번째 [Dynamic programming]

동적 계획법은 큰 문제를 작은 문제로 분할하여 푸는 방식의 알고리즘이다.  
처음 주어진 문제를 더 작은 문제들로 나눠준 다음 각 문제들의 답을 계산하고 계산된 답을 이용하여 원래 문제에 대한 답을 계산하는 것에서 <b>분할 정복(Divide Conquer)</b> 문제와 비슷할 수도 있다. 그러나 분할 정복 문제와 가장 큰 차이점은 동적 계획법은 작은 문제들이 중복될 수 있지만 분할 정복에서는 중복되지 않는 다는 점이다.
<br/><br/>
다시 말하자면 둘의 차이는 문제를 나누는 방식이 되겠다.

동적 계획법에서는 어떤 부분 문제는 두 개 이상의 큰 문제를 해결하는데 사용될 수 있기에, 이 부분 문제를 여러번 계산하는 대신 한번만 계산하며 해당 부분 문제의 결과를 재사용함으로써 비용을 감소시킨다.
<br/><br/>
동적 계획법은 두가지 속성을 만족해야한다.

**1. Overlapping Subproblem: 겹치는 부분(작은) 문제**  
**2. Optimal Substructure: 최적 부분 구조**

### 겹치는 부분 문제 (Overlapping Subproblem)

어떤 문제가 여러개의 부분문제로 쪼개질 수 있을때 사용하는 용어이다.  
<b>‘부분 문제’</b>는 항상 새로운 부분 문제를 생성해내기 보단 앞서 같은 부분 문제가 여러번 재사용되거나 재귀 알고리즘을 통해 해결되는 문제를 가리킨다.  
대표적인 예시로 피보나치 수열이 있다. 피보나치 수열은 대표적인 재귀 함수로 아래와 같이 표현이 가능하다.

```
fib(1) = 1
fib(2) = 1
fib(n) = fib(n-1) + fib(n-2) (n >= 2)
fib(3) = fin(2) + fib(1)
fib(4) = fin(3) + fib(2)
```

겹치는 부분 문제가 있다면 큰 문제는 작은 문제들을 통해 정답을 구할 수 있다.  
큰 문제는 작은 문제와 같은 방법으로 풀 수 있으며(재귀적으로), 모든 문제를 작은 문제로 쪼갤 수 있기 때문이다.

### 최적 부분 구조 (Optimal Substructure)

어떤 문제의 최적의 해결책이 그 부분 문제의 최적의 해결책으로 부터 설계될 수 있는 경우다.  
피보나치에서 큰 문제의 답인 <b>fib(n)</b>이 최적의 답이 되기 위해선 작은 부분 문제인 <b>fib(n-1)</b>과 <b>fib(n-2)</b>가 최적의 답이어야 한다.
작은 최적의 답으로 큰 문제의 최적의 답을 구할 수 있는 것이다.  
그리고 <b>fib(n-1)</b>을 구하기위해 <b>fib(n-2) + fib(n-3)</b>이 되고, 이 때 <b>fib(n-2)</b>가 중복이 된다.
그리고 최적 부분 구조를 만족하면, 문제의 크기가 어떻게 되든 어떤 한 문제의 답을 일정하게된다.

만약 6번째 피보나치 수를 구하기 위해서 구하는 4번째 피보나치 수  
5번째 피보나치 수를 구하기 위해서 구하는 4번째 피보나치 수  
4번째 피보나치 수를 구하기 위해서 구하는 4번째 피보나치 수는 항상 같기에 겹치는 부분문제의 정답은 항상 같다.
<br/><br/>
**이처럼 같은 값을 매번 n번째의 피보나치 수를 계산하기 위해 구하는 것이 옳은 것일까?**

매우 비효율적일 것이다.  
그리고 이런 비효율적인 계산 방법을 해결하기 위해 등장한 것이 바로 <b>메모이제이션(Memoization)</b>이다.

### 메모이제이션(Memoization)

동적 계획법에서 빠지기 힘든 것이 바로 메모이제이션이다.  
메모이제이션은 말 그대로 <b>“메모”</b>하는 기법으로 부분 문제의 계산된 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거한다.
다시 말해 메모리에 계산된 값을 저장해 나가며 다음 반복 수행 때 연산 없이 저장된 값을 불러오는 방법이다. 이때 값을 저장하는 메모리(배열)를 <b>캐시(Cache)</b>라고 한다.
<br/><br/>
미리 저장하고 재사용 가능하기 때문에 모든 문제를 한 번씩만 풀게 된다.  
시간 복잡도는 <b>(문제의 개수 X 문제 1개를 푸는 시간)</b>이 되고 문제의 개수가 N일때
전체 시간 복잡도는 <b>O(N)</b>을 가진다.

메모이제이션이서 문제를 접근하는 방식은 2가지가 있다.

### Top-down

큰 문제를 가장 작은 문제까지 나누고 작은 문제를 해결한 다음에 큰 문제를 해결하는 방식이다.  
주로 “재귀”를 이용해서 문제를 푼다.

```javascript
let memo = new Array(100).fill(0)

function fibonacci(num) {
  if (num <= 1) {
    return num
  } else {
    // memo[num]에 값이 존재한다면 이미 구한 것이므로 계산된 값을 재사용한다.
    if (memo[num] > 0) return memo[num]
    memo[num] = fibonacci(num - 1) + fibonacci(num - 2)
    return memo[num]
  }
}

console.log(fibonacci(10))
```

### Bottom-up

가장 작은 문제부터 차례대로 해결하며 큰 문제를 해결하는 방식이다.  
특징은 작은 문제를 먼저 해결하기에 큰 문제는 항상 해결할 수 있다.  
주로 반복문을 이용하여 문제를 푼다.

```javascript
let memo = new Array(100).fill(0)

function fibonacci(num) {
  memo[0] = 0
  memo[1] = 1
  for (let i = 2; i <= num; i++) {
    memo[i] = memo[i - 1] + memo[i - 2]
  }
  return memo[num]
}

console.log(fibonacci(10))
```

### DP 문제

동적 계획법을 이용한 다른 문제도 한번 살펴보자

**1. LCS (최장 공통 부분 수열) 문제**

최장 공통 부분 수열(LCS) 문제는 두개의 문자열에서 순서대로 겹치는 문자의 최대 길이를 구하는 문제이다.
해당 문제는 [LCS 포스팅](https://leejy001.github.io/2022-03-09/LCS/)에 자세히 나와있다.
<br/><br/>

**2. 0/1 배낭 문제**

배낭 문제는 배낭에 일정 무게 제한이 걸려있고 해당 배낭에 물건을 여러개 넣고자 할 때 넣은 물건들의 가치를 최대가 되도록 하는 문제다.
문제 이름이 0/1인 이유는 물건을 쪼개서 넣지는 못하기 때문에 통째로 넣거나 아예 넣지 않거나 둘 중 하나이기 때문에 붙여진 이름이다.

> 무게 제한이 50이고 넣을 물건의 무게와 가치는 각각 (10, 60), (20, 100), (30, 120)이라고 하자  
> 배낭의 무게 제한을 넘지 않는 선에서 물건을 넣어 배낭안의 물건들의 가치가 최대가 되도록 한다.

이 문제를 풀어본다면 최적의 조합은 무게가 20인 물건과 30인 물건을 넣어 가치를 220으로 맞추면 된다.  
하지만 컴퓨터는 최적의 조합을 스스로 찾지 못한다. 하지만 계산(노가다)은 잘한다.
<br/><br/>
**배낭 문제 코드**

```javascript
let item = [
  [1, 60, 10],
  [2, 100, 20],
  [3, 120, 30],
]

function knapsack(item, cap) {
  let memo = []

  for (let i = 0; i <= item.length; i++) {
    memo[i] = []
  }

  for (let i = 0; i < item.length + 1; i++) {
    for (let j = 0; j <= cap; j++) {
      if (i === 0 || j === 0) {
        // 1
        memo[i][j] = 0
      } else if (item[i - 1][2] > j) {
        // 2
        memo[i][j] = memo[i - 1][j]
      } else {
        // 3
        memo[i][j] = Math.max(
          memo[i - 1][j],
          memo[i - 1][j - item[i - 1][2]] + item[i - 1][1],
        )
      }
    }
  }
  return memo[item.length][cap]
}

console.log(knapsack(item, 50))
```

배낭문제는 대체적으로 위의 LCS 문제와 처음 초기화 방식이 비슷하다.  
2차원 적으로 배열을 선언해주고 0번째 행과 열에 마진으로 0을 부여하고 행은 넣을 수 있는 물건의 개수, 열은 배낭의 무게로 지정해주면 된다.
이때 물건의 개수에 따라 앞에서 부터 차례대로 넣어준다는 것을 잊지 말자  
메모이제이션할 배열을 memo라고 한다면 <b>memo[i][w]</b>은 i개의 물건과 w의 무게 제한으로 가능한 최대 가치를 의미한다.

1. 어떠한 물건도 선택하지 않았거나 무게가 없다면 <b>memo[i][w]</b>는 0이다.
2. i번째 물건의 무게가 무게 제한을 초과한다면 <b>memo[i][w] = memo[i-1][w]</b>이다.  
   즉 마지막에 넣어놨던 물건 하나를 다시 뺀 가치가 답이 된다.
3. 초과 하지 않는 경우에는 마지막 물건 한 개를 제외한 가치와 이전 물건을 제외하고 새로 넣은 물건의 가치 중 가장 큰 값을 골라야 한다.
   설명을 더하자면 무게 제한이 40까지 넣을 수 있을 때 무게가 10과 20을 더한 가치(160)와 무게가 10과 30을 더한 가치(180)을 계산할 때를 생각하면 된다.  
   위 코드에서 2차원 배열의 memo의 출력 결과를 보면서 설명을 이해하면 된다.  
   memo[3][40]일때 memo[2][40]인 경우의 가치 `무게 10 + 무게 20 = 가치 160` 와 memo[2][10]인 경우에 + item[2][1]의 가치`무게 10 + 무게 30 = 가치 180`를 비교해보면 후자가 가치가 더 큰 것을 알 수 있다.

이를 식으로 풀면 `memo[i][w] = max(memo[i-1][w], memo[i-1][w-무게] + 가치)`가 된다.
<br/><br/>
동적 계획법은 푸는 사람이 구하고자 하는 방식을 어떻게 할지, 어떤 방식으로 식을 세울지 따라 다르다.  
고로 많이 문제를 접해보는 것이 중요하다.
