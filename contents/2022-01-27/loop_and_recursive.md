---
date: '2022-01-27'
title: '반복문과 재귀'
categories: ['JavaScript', 'Algorithm']
summary: '알고리즘에서 가장 많이 사용하는 반복문과 재귀에 대해서 알아보자'
thumbnail: './javascript_thumbnail.png'
---

### 알고리즘 정리 첫번째 [재귀와 반복문]

알고리즘 문제를 풀 때 가장 많이 사용하게 되는 기본적인 구조가 아닌가 싶다.  
보통 while, for 문 같은 반복문을 이용하여 문제를 풀고 반복문으로 풀기 어렵거나 재귀적으로 접근 하는 것이 더 빠른 문제 같은 경우
재귀 함수를 사용하여 문제에 접근한다.  
<b>재귀(Recursion)</b>와 <b>반복문(Iteration)</b> 둘의 차이점과 장단점은 어떨까?

### 재귀(Recursion)와 반복문(Iteration)

재귀 함수를 간단하게 설명하자면 자기 자신을 계속 호출하는 함수를 재귀 함수라고 한다.  
다음은 반복문과 재귀를 비교하면 다음과 같다.

**반복문**  
<b>기본</b> : 일련의 명령을 반복적으로 수행  
<b>체재</b> : 반복에는 초기화, 조건, 루프 내의 명령문 실행 및 제어 변수 업데이트 포함  
<b>종료</b> : 설정한 조건에 도달 할 때까지 반복 실행  
<b>조건</b> : 제어 조건이 참이라면 무한 반복 발생  
<b>무한 반복</b> : 무한 루프는 CPU 사이클을 반복적으로 사용  
<b>스택 메모리</b> : 스택 메모리를 사용하지 않음  
<b>속도</b> : 빠른 실행  
<b>가독성</b> : 코드 길이가 길어지고 변수가 많아서 가독성 떨어짐

**재귀함수**  
<b>기본</b> : 함수 자체를 호출  
<b>체재</b> : 기본적으로 종료 조건만 지정  
<b>종료</b> : 함수 호출 본문에 조건부가 포함, 재귀를 호출하지 않고 함수 강제 반환  
<b>조건</b> : 조건에 수렴하지 않을 경우 무한 재귀 발생  
<b>무한 반복</b> : 무한 재귀는 스택 오버플로우 발생  
<b>스택 메모리</b> : 함수가 호출 될 때마다 새 로컬 변수와 매개 변수 집합을 저장하는데 사용  
<b>속도</b> : 느린 실행  
<b>가독성</b> : 코드 길이와 변수가 적어 가독성 높음

### 재귀함수를 사용하는 이유

따지고 보면 반복문 보단 좋은 점은 없다.  
재귀함수는 stack이라는 메모리 공간을 사용하고 반복적으로 자기 자신을 호출하며 stack에 계속해서 쌓이기에 성능이 좋진 않다.
재귀함수는 stack의 메모리 공간을 이용하기에 무한 재귀가 발생한다면 메모리 제한이 있는 한 <b>stack overflow</b>가 발생하며 프로그램이 비정상 종료된다.
그리고 함수의 호출 및 복귀를 위한 context switching 비용이 발생하여 속도가 상대적으로 느리다.

<b>위와 같은 이유에도 불구하고 재귀함수를 쓰는 이유는 무엇일까?</b>

<br/>

**1. 알고리즘 자체가 재귀적인 표현이 자연스럽다면 재귀 함수를 쓰는 것이 유용하다.**  
재귀를 설명할 때 단골로 나오는 피보나치 수열 점화식이 있다. `ex) f(n) = f(n-1) + f(n-2)`  
f(n)을 구하기 위해선 f(n-1), f(n-2)처럼 자기자신의 함수를 인자만 바꾸고 다시 호출해야한다.  
이런 경우엔 반복문도 가능하지만 재귀함수를 사용하면 더 간단하게 구현이 가능하다.

반복문으로 피보나치 수열을 구현 하려면 아래 코드와 같이 변수 a, b, c가 필요하다.

```javascript
let a = 1
let b = 1
for (let i = 0; i < 5; i++) {
  let c = a + b
  a = b
  b = c
}

console.log(b)
```

하지만 재귀를 활용한다면 다음과 같이 작성할 수 있다.

```javascript
function fibo(num) {
  if (num === 1 || num === 2) {
    return 1
  }
  return fibo(num - 1) + fibo(num - 2)
}

console.log(fibo(7))
```

**2. 변수 사용을 줄여준다.**  
변수가 적을 수록 프로그램에 오류가 생길 가능성이 적고 프로그램이 정확히 실행되는지에 대한 증명이 간단해진다.  
mutable state(가변 상태)를 줄일 수 있기에 side effect(예상외 작용)가 없다.
물론 직관적이지 않은 재귀 호출이 이해하는 데는 어려울 수 있지만 오류 없는 프로그램을 짜는 데도 중요한 사항이 된다.

**3. 가독성이 향상된다.**  
반복문에 비해서 재귀는 코드량이 줄고 사용 변수도 적기에 가독성이 향상된다.  
오직 성능만 본다면 메모리 사용량이나 속도 등 반복문에 비해 성능 면에서 뒤쳐지는 게 많지만 협업이 주를 이루는 개발 상황을 생각하면
가독성 역시 중요하기에 해당 프로그램의 목적을 고려해서 재귀 함수를 사용하는 것이 올바르다.

### 꼬리 재귀 (Tail Recursion)

함수를 호출하면 함수가 호출된 위치를 주소 값이 지정해야한다.  
함수가 재귀적으로 호출된 경우 함수안에서 함수가 호출되고 차례로 리턴된다.
그런데 이러한 호출 횟수가 많아지면 돌아갈 곳의 주소 값을 저장하는 스택이 넘치거나 프로그램의 실행 속도가 저하된다.  
위와 같은 문제는 함수가 호출된 위치를 기억하기에 발생하게 되는데 일반적인 재귀 함수의 경우엔 리턴되는 함수 값을 받아 다시 연산하고
다시 그 값을 리턴해준다.

이런 문제를 해결하기 위해 <b>꼬리 재귀</b>가 사용된다.  
꼬리 재귀는 재귀 함수를 원래 함수의 꼬리 부분에서 호출하는 경우를 말하는데 컴파일러는 꼬리 재귀로 작성된 코드를 반복문으로 바꾼다.
코드 상으로 해결되는 것이 아니라 컴파일러가 꼬리 재귀를 인식하고 코드를 최적화 하면서 일반적으로 재귀가 가진 단점을 없애준다.
꼬리 재귀는 함수가 호출된 위치로 돌아갈 때 실행할 작업을 없애줘서 함수 호출 위히를 저장하지 않도록 하여 스택이 넘치는 경우를 방지한다.

반복문, 재귀, 꼬리 재귀의 예시는 다음과 같다.

```javascript
// 반복문
let sum = 0
for (let i = 0; i <= 100; i++) {
  sum += i
}
console.log(sum)

// 재귀
function recursiveSum(num) {
  if (num === 100) return num
  else return num + recursiveSum(num + 1)
}
console.log(recursiveSum(0))

// 꼬리 재귀
function tailRecursiveSum(num, acc) {
  if (num > 100) return acc
  else return tailRecursiveSum(num + 1, num + acc)
}
console.log(tailRecursiveSum(0, 0))
```

꼬리 재귀는 결국 반복문 실행이기에 일반 재귀 함수에서처럼 stack overflow와 같은 성능 저하는 발생하지 않는다.  
즉 재귀 모습을 한 반복문이라 볼 수 있다.
