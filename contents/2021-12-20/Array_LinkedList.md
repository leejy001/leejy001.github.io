---
date: '2021-12-20'
title: '배열과 연결리스트 (Array & Linked List)'
categories: ['Data Structure']
summary: '배열과 연결리스트에 대해 알아보고 둘의 차이를 비교해보자'
thumbnail: './array_linkedlist_thumbnail.png'
showThumbnail: true
---

### 개발자가 알아야 하는 자료구조 8가지

**1. 배열 (Array)**  
**2. 연결 리스트 (Linked List)**

배열과 연결리스트는 둘 다 데이터를 저장하는 방식의 일종이며 이 두가지의 기본적인 형태가 수많은 자료구조를 만드는 뼈대가 되며 어떻게 효율적으로 데이터를 저장하는지가 알고리즘이라 할 수 있다.

### 배열이란?

배열은 특정 자료형이 메모리 공간상에서 연속적으로 이루어져 있는 자료구조를 의미한다.  
그리고 이러한 연속적인 공간들은 0부터 시작하는 Index 값에 의해 즉각적으로 참조될 수 있다.

<p align="center"><img src='/images/DataStructure/array.png' width='80%' alt='table' /><p>

### 배열의 특징은 어떨까?

무엇보다 데이터에 대한 접근은 연결리스트보다 더 빠르다는 것이다.  
위에 언급했듯이 Index 값을 통해 바로 원하는 공간의 자료를 확인 할 수 있기에 수학적으로 O(1)의 검색 시간복잡도를 가진다. 따라서 데이터를 검색하거나 빠른 접근이 필수적인 자료구조에 많이 이용한다.  
그러나 단점으로는 배열은 처음 선언할 때부터 배열의 크기를 지정해 놓는다. 배열의 최대 크기를 변경할 수 없다.
<br/><br/>
자바스크립트에서 배열을 만드는 방법은 2가지가 있다.

**첫번째로 배열 리터럴 대괄호([])를 이용하는 방법이 있다.**

```javascript
// 배열 생성 (빈 배열)
let arr = []
arr[0] = 'zero'
arr[1] = 'one'
arr[2] = 'two'

for (let i = 0; i < arr.length; i++) {
  console.log(arr[i])
}
```

```javascript
// 배열 생성 (초기 값 할당)
let arr = ['zero', 'one', 'two];

for (let i = 0; i < arr.length; i++) {
  console.log(arr[i]);
}
```

```javascript
// 배열 생성 (배열 크기 지정)
// 쉼표 개수만큼 크기 저장
let arr = [, , ,]

for (let i = 0; i < arr.length; i++) {
  console.log(arr[i])
}
```

**두번째로는 Array() 생성자 함수로 배열을 생성하는 방법이 있다.**

```javascript
// 배열 생성 (빈 배열)
let arr = new Array()

arr[0] = 'zero'
arr[1] = 'one'
arr[2] = 'two'

for (let i = 0; i < arr.length; i++) {
  console.log(arr[i])
}
```

```javascript
// 배열 생성 (초기 값 할당)
let arr = new Array('zero', 'one', 'two')

for (let i = 0; i < arr.length; i++) {
  console.log(arr[i])
}
```

```javascript
// 배열 생성 (배열 크기 지정)
// 원소가 1개이고 숫자인 경우 배열 크기로 사용된다.
let arr = new Array(3)

for (let i = 0; i < arr.length; i++) {
  console.log(arr[i])
}
```

자바스크립트는 배열같은 경우 다른 언어와 달리 배열 내부의 데이터 타입이 서로 다를 수 있으며 배열의 크기를 동적으로 변경할 수 있다는 특징이 있다. 그래서 다음과 같이 배열을 이용할 수 있다.

```javascript
// 서로 다른 데이터 타입 담기
let arr = [1234, 'test', true]

// 배열의 크기를 임의로 변경 (3 -> 5)
// arr[3], arr[4]는 값이 할당 되지 않았기 때문에 undefined
arr.length = 5

// 새로운 배열 추가하면 크기 자동으로 변경 (5 -> 6)
arr[5] = 'apple'

// 새로운 배열 추가로 크기 변경 (6 -> 7)
arr.push = 123

for (let i = 0; i < arr.length; i++) {
  console.log(arr[i])
}
```

자바스크립트의 배열은 변수 외에도 객체나 함수도 담을 수 있으며, 배열이 생성된 즉시 크기도 임의로 변경이 가능하고 이미 할당된 값은 삭제되지 않는다.
자바스크립트의 배열은 제약사항이 적어 자유롭게 사용이 가능하나 반대로 많은 주의도 기울어야한다.

### 연결리스트란?

연결 리스트는 여러개의 노드가 연결된 형태의 자료구조를 의미한다.  
연속된 메모리 공간을 차지하는 배열과는 달리 메모리 공간 상에서 각 노드들이 연속적으로 연결되어 있지 않고 흩어져 있으며 각각의 노드가 link를 통해 자신의 다음 노드의 위치를 알려주는 형태로 구성되어 있다.

**그럼 노드는 무엇일까?**  
배열의 한 칸의 원소와 유사하다고 생각하면 편하다. 각각의 노드들은 내부적으로 자신의 안에 포함할 데이터와 다음 노드의 위치 정보를 가지고 있다.
이러한 노드가 연결이 되어 있는 형태가 연결리스트이고 다음과 같은 형태로 나타난다.

<p align="center"><img src='/images/DataStructure/linked_list.png' width='80%' alt='table' /><p>

### 그렇다면 연결리스트의 시간복잡도는 어떨까?

<p align="center"><img src='/images/DataStructure/linked_list_add.png' width='80%' alt='table' /><p>

먼저 삽입의 경우부터 살펴보자 연결리트에 삽입할 때는 기존의 링크를 끊고 다음 추가할 위치의 이전 노드의 꼬리와 삽입할 자료를 연결한다.
그리고 추가할 노드의 꼬리와 다음 노드를 연결해주면 된다.  
이때 오직 앞 요소와 다음 요소를 연결시켜주는 동작만 수행되므로 시간 복잡도는 O(1)으로 표현할 수 있지만..
현실적으로는 가장 처음의 노드를 제외하곤 나머지 노드들은 탐색을 통해 가지고 와야하기 때문에 O(n)이라 볼 수 있다.

<p align="center"><img src='/images/DataStructure/linked_list_remove.png' width='80%' alt='table' /><p>

삭제의 경우에는 삭제하고자 하는 노드의 이전 노드의 꼬리를 다음 노드에 연결해주면 된다.  
삭제하고자 하는 노드의 이전 노드와 다음 노드를 연결시키는 동작을 수행하기에 시간 복잡도는 O(1)로 표현할 수 있다.
역시 삭제의 경우도 마찬가지로 현실적으로 가장 처음의 노드를 제외하곤 탐색을 해야하기 때문에 O(n)이라 볼 수 있다.
<br/><br/>
마지막으로 연결리스트에서 특정 자료를 검색하고자 할 때 연결 리스트의 각 노드들은 다음 요소들의 정보를 가지고 있기 때문에 맨 앞의 노드부분부터 순차적으로 자료를 찾아야한다.
이때의 시간 복잡도는 O(n)으로 표기할 수 있다.

### 배열 vs 연결리스트

배열은 메모리 사용이 비효율적이며, 배열 내의 데이터 추가 및 삭제의 시간 복잡도가 O(n)이라는 단점이 있다.  
반대로 연결리스트는 메모리를 효율적으로 사용하며 삽입, 삭제에 대해서도 효율적으로 할 수 있다는 장점도 있지만 <br/>그만큼 많은 단점도 가지고 있다.
<br/><br/>

**1. 캐싱에 적합하지 않은 구조**  
연결리스트 탐색은 loop를 돌아야하므로 O(n)의 시간 복잡도를 가지며 배열 리스트의 탐색은 인덱싱을 이용하기 때문에 O(1)의 시간 복잡도를 가진다.
배열 리스트의 연산이 연결 리스트에 비해 빠른 이유는 뭘까?  
그 이유는 컴퓨터 내부의 캐시(Cache)라는 저장 공간 때문이다.
캐시에 대해 간단히 설명하자면 CPU와 주기억장치 <br/>사이에 설치된 메모리이며 둘 사이의 데이터 처리 속도를 조절하기 위해 주기억장치에 있는 자주 사용하는 정보를 캐시에 미리 적재한다.
그렇게 되면 CPU는 주기억장치가 아닌 캐시에서 정보를 가져오며 즉각 명령을 처리할 수 있게된다.
<br/><br/>
배열의 경우 데이터들이 연속된 메모리 공간에 있기메 메모리에서 캐시로 데이터를 넘기면 한꺼번에 데이터가 넘어가서 CPU가 빠르게 이들을 처리할 수 있다.
그러나 연결리스트의 경우 데이터를 메모리 곳곳에 저장한 후 이들을 주소로만 연결한 구조이기 때문에 데이터가 캐시로 한번에 넘어가지 못하며 CPU가 이들이 넘어올 때까지 기다려야 하기 때문에 처리속도가 매우 느리다.
<br/><br/>

**2. 복잡한 연산에 따른 오버헤드 발생**  
구조상으로 배열보단 연결리스트의 연산이 더 복잡하다.
때문에 모든 연산을 수행할 시 더 많은 명령어가 필요하고 더 많은 오버헤드가 발생할 수 밖에 없으며 이러한 이유로 알고리즘의 시간 복잡도 외에 추가적인 시간이 소모된다.
<br/><br/>

**3. 참조 포인터(주소 저장)로 인한 공간 낭비**  
연결 리스트의 경우 데이터 이외에 다음 노드의 주소에 대한 정보를 저장하기 때문에 배열보다 더 많은 용량이 필요하다.

<br/><br/>

지금까지 배열과 연결리스트에 대해 알아봤다.  
데이터의 접근 및 탐색이 중점이라면 배열을, 데이터의 추가, 삭제가 중요한 경우에는 연결리스트를 이용하는 것이 좋다.  
다음 시간에는 연결리스트의 종류에 대해 알아보도록 하자
